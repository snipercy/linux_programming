# cp : 实现bash中的cp(copy)命令
命令用法：`$cp srcfile targetfile`
如果targetfile所指定的文件不存在，cp就创建这个文件；如果文件已经存在则覆盖，targetfile的内容与srcfile相同。

##  1. 程序流程：

```c
  open sourcefile for reading
  open copyfile for writing
  +->read from source to buffer -- eof?-+
  |				                        |
  -- write from buffer to copy		    |
  					                    |
  	  close sourcefile <----------------+
 	  close copyfile
```

用户态的进程是不能访问内核空间的，否则就会出现`segmentfault`，因为没有访问权限，所以处于内核态的用户进程需要将**数据拷贝**到用户空间，这是系统调用开销大原因之一。

扯一句，在网络编程模型中，为什么`epoll`比`select`/`poll`效率高，其中一个原因就是`epoll`减少了`fd`集合的拷贝。(* 先挖两个坑，`syscall`和`epoll`相关知识将将用两篇博文来整理一下*)

另一个导致`syscall`开销大的的原因是：**运行环境的切换**。用户进程(`cp`)位于用户空间，内核位于系统空间，`cp`所要操作的文件是位于磁盘中的，而磁盘等设备只能被处于特权级(`ring 0`)的进程直接访问，即处于内核态的进程才可以访问。用户进程要想获得特权级，需要陷入内核态，可以通过系统调用来实现。具体到`cp`命令就通过调用`read`和`write`等`syscall`使得执行权从用户代码转换到内核代码，这种切换是需要时间的。
当运行内核代码时，`cpu`工作在特权级(ring 0)，此时，内核代码使用内核空间中的堆栈和内存环境(内核空间)，这些需要在内核代码执行前准备好，系统调用结束后(read返回时)，cpu又需要切换到用户模式。
有一个形象的例子来说明这种切换的开销：超人-普通人之间切换：换衣服开销


## 2. 利用缓存提升程序效率

在一般的操作系统书中都会说缓存是为了协调速率不匹配

#### a. 应用缓冲技术

先看这样一个生活场景：我们需要煎3个荷包蛋，每次取超市买一个鸡蛋，回家煎好后再去超市买一个。显然，这是很低效的做法，完全可以一次性买3个鸡蛋再煎荷包蛋。

cp命令也是做类似的事情：超市里的购物车对应于缓存，鸡蛋对应于源文件内容，荷包蛋对应于目标文件。cp要做的就是一次性尽可能多的将源文件中的内容拷贝到缓存文件中，再将缓存中文件拷贝到目标文件中，从而减少read和write调用的次数。

总结一下，应用缓存的主要思想是一次读入大量的数据放入缓冲区中，需要的时候从缓冲区中取得数据。


#### b. 内核缓冲技术

上述的**应用缓冲技术**是为了减少系统调用的次数，从而提高程序的效率。而**内核缓冲技术**


使用缓存减少系统调用的次数，从而提高文件I/O效率
应用缓存技术：由于系统调用慢，一次读入大量的数据放入缓冲区，减少系统调用
运行环境的切换开销大，比如：超人-普通人之间切换：换衣服开销
### 系统缓存技术
I/O比系统调用还慢，所以需要缓存技术提高对磁盘访问速度。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求数据队列表中，然后把该进程挂起，接着为其他进程服务。
一段时间后，内核把相应数据块从磁盘读到内核缓冲区，然后再把数据复制到进程缓冲区中，最后唤醒被挂起的进程。
read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程过程区写到内核缓冲区。
#### 应用内核缓冲技术导致的结果
- 提高磁盘I/O效率
- 优化磁盘的写操作
- 需要及时地将缓冲数据写入磁盘
